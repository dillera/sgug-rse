diff -u -r glib-2.62.6-orig/gio/glocalfile.c glib-2.62.6/gio/glocalfile.c
--- glib-2.62.6-orig/gio/glocalfile.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/glocalfile.c	2020-12-15 17:22:06.473139640 +0000
@@ -2826,7 +2826,7 @@
       if (g_cancellable_set_error_if_cancelled (state->cancellable, error))
         return FALSE;
 
-#ifdef AT_FDCWD
+#if defined(AT_FDCWD)
 #ifdef HAVE_OPEN_O_DIRECTORY
       dir_fd = openat (parent_fd, name->data, O_RDONLY|O_DIRECTORY);
 #else
@@ -2854,7 +2854,7 @@
   const gchar *name;
   GDir *dir;
 
-#ifdef AT_FDCWD
+#if defined(AT_FDCWD)
   {
     /* If this fails, we want to preserve the errno from fopendir() */
     DIR *dirp;
diff -u -r glib-2.62.6-orig/gio/gsocket.c glib-2.62.6/gio/gsocket.c
--- glib-2.62.6-orig/gio/gsocket.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/gsocket.c	2020-12-15 17:22:06.483543480 +0000
@@ -4419,6 +4419,119 @@
 
 /* Unfortunately these have to be macros rather than inline functions due to
  * using alloca(). */
+
+#if defined(__sgi)
+
+// Replace the non-xpg5 macros
+#undef CMSG_FIRSTHDR
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t)(mhdr)->msg_ctrllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr*) (mhdr)->msg_ctrl : (struct cmsghdr*)NULL)
+
+# undef CMSG_NXTHDR
+# define CMSG_NXTHDR(mhdr, cmsg)					\
+  (((caddr_t)(cmsg) + (cmsg)->cmsg_len + sizeof(struct cmsghdr) >	\
+    (caddr_t)(mhdr)->msg_ctrl + (mhdr)->msg_ctrllen) ?			\
+   (struct cmsghdr *)0L :						\
+   (struct cmsghdr *)((caddr_t)(cmsg) + _ALIGN((cmsg)->cmsg_len)))
+
+// And prototype the xpg send/recv
+extern ssize_t _xpg5_recvmsg(int, struct xpg5_msghdr *, int);
+extern ssize_t _xpg5_sendmsg(int, const struct xpg5_msghdr *, int);
+
+#define output_message_to_msghdr(message, prev_message, msg, prev_msg, error) \
+G_STMT_START { \
+  const GOutputMessage  *_message = (message); \
+  const GOutputMessage *_prev_message = (prev_message); \
+  struct xpg5_msghdr *_msg = (msg); \
+  const struct xpg5_msghdr *_prev_msg = (prev_msg); \
+  GError **_error = (error); \
+ \
+  /*_msg->msg_flags = 0;*/                      \
+ \
+  /* name */ \
+  if (_prev_message != NULL && _prev_message->address == _message->address) \
+    { \
+      _msg->msg_name = _prev_msg->msg_name; \
+      _msg->msg_namelen = _prev_msg->msg_namelen; \
+    } \
+  else if (_message->address != NULL) \
+    { \
+      _msg->msg_namelen = g_socket_address_get_native_size (_message->address); \
+      _msg->msg_name = g_alloca (_msg->msg_namelen); \
+      if (!g_socket_address_to_native (_message->address, _msg->msg_name, \
+                                       _msg->msg_namelen, _error)) \
+        break; \
+    } \
+  else \
+    { \
+      _msg->msg_name = NULL; \
+      _msg->msg_namelen = 0; \
+    } \
+ \
+  /* iov */ \
+  { \
+    /* this entire expression will be evaluated at compile time */ \
+    if (sizeof *_msg->msg_iov == sizeof *_message->vectors && \
+        sizeof _msg->msg_iov->iov_base == sizeof _message->vectors->buffer && \
+        G_STRUCT_OFFSET (struct iovec, iov_base) == \
+        G_STRUCT_OFFSET (GOutputVector, buffer) && \
+        sizeof _msg->msg_iov->iov_len == sizeof _message->vectors->size && \
+        G_STRUCT_OFFSET (struct iovec, iov_len) == \
+        G_STRUCT_OFFSET (GOutputVector, size)) \
+      /* ABI is compatible */ \
+      { \
+        _msg->msg_iov = (struct iovec *) _message->vectors; \
+        _msg->msg_iovlen = _message->num_vectors; \
+      } \
+    else \
+      /* ABI is incompatible */ \
+      { \
+        gint i; \
+ \
+        _msg->msg_iov = g_newa (struct iovec, _message->num_vectors); \
+        for (i = 0; i < _message->num_vectors; i++) \
+          { \
+            _msg->msg_iov[i].iov_base = (void *) _message->vectors[i].buffer; \
+            _msg->msg_iov[i].iov_len = _message->vectors[i].size; \
+          } \
+        _msg->msg_iovlen = _message->num_vectors; \
+      } \
+  } \
+ \
+  /* control */ \
+  { \
+    struct cmsghdr *cmsg; \
+    gint i; \
+ \
+    _msg->msg_ctrllen = 0; \
+    for (i = 0; i < _message->num_control_messages; i++) \
+      _msg->msg_ctrllen += CMSG_SPACE (g_socket_control_message_get_size (_message->control_messages[i])); \
+ \
+    if (_msg->msg_ctrllen == 0) \
+      _msg->msg_ctrl = NULL; \
+    else \
+      { \
+        _msg->msg_ctrl = g_alloca (_msg->msg_ctrllen); \
+        memset (_msg->msg_ctrl, '\0', _msg->msg_ctrllen); \
+      } \
+ \
+    cmsg = CMSG_FIRSTHDR (_msg); \
+    for (i = 0; i < _message->num_control_messages; i++) \
+      { \
+        cmsg->cmsg_level = g_socket_control_message_get_level (_message->control_messages[i]); \
+        cmsg->cmsg_type = g_socket_control_message_get_msg_type (_message->control_messages[i]); \
+        cmsg->cmsg_len = CMSG_LEN (g_socket_control_message_get_size (_message->control_messages[i])); \
+        g_socket_control_message_serialize (_message->control_messages[i], \
+                                            CMSG_DATA (cmsg)); \
+        cmsg = CMSG_NXTHDR (_msg, cmsg); \
+      } \
+    g_assert (cmsg == NULL); \
+  } \
+} G_STMT_END
+
+#else
+
 #define output_message_to_msghdr(message, prev_message, msg, prev_msg, error) \
 G_STMT_START { \
   const GOutputMessage  *_message = (message); \
@@ -4427,7 +4540,7 @@
   const struct msghdr *_prev_msg = (prev_msg); \
   GError **_error = (error); \
  \
-  _msg->msg_flags = 0; \
+  /*_msg->msg_flags = 0;*/                      \
  \
   /* name */ \
   if (_prev_message != NULL && _prev_message->address == _message->address) \
@@ -4510,6 +4623,73 @@
   } \
 } G_STMT_END
 
+#endif
+
+#if defined(__sgi)
+
+#define input_message_to_msghdr(message, msg) \
+G_STMT_START { \
+  const GInputMessage  *_message = (message); \
+  struct xpg5_msghdr *_msg = (msg); \
+ \
+  /* name */ \
+  if (_message->address) \
+    { \
+      _msg->msg_namelen = sizeof (struct sockaddr_storage); \
+      _msg->msg_name = g_alloca (_msg->msg_namelen); \
+    } \
+  else \
+    { \
+      _msg->msg_name = NULL; \
+      _msg->msg_namelen = 0; \
+    } \
+ \
+  /* iov */ \
+  /* this entire expression will be evaluated at compile time */ \
+  if (sizeof *_msg->msg_iov == sizeof *_message->vectors && \
+      sizeof _msg->msg_iov->iov_base == sizeof _message->vectors->buffer && \
+      G_STRUCT_OFFSET (struct iovec, iov_base) == \
+      G_STRUCT_OFFSET (GInputVector, buffer) && \
+      sizeof _msg->msg_iov->iov_len == sizeof _message->vectors->size && \
+      G_STRUCT_OFFSET (struct iovec, iov_len) == \
+      G_STRUCT_OFFSET (GInputVector, size)) \
+    /* ABI is compatible */ \
+    { \
+      _msg->msg_iov = (struct iovec *) _message->vectors; \
+      _msg->msg_iovlen = _message->num_vectors; \
+    } \
+  else \
+    /* ABI is incompatible */ \
+    { \
+      guint i; \
+ \
+      _msg->msg_iov = g_newa (struct iovec, _message->num_vectors); \
+      for (i = 0; i < _message->num_vectors; i++) \
+        { \
+          _msg->msg_iov[i].iov_base = _message->vectors[i].buffer; \
+          _msg->msg_iov[i].iov_len = _message->vectors[i].size; \
+        } \
+      _msg->msg_iovlen = _message->num_vectors; \
+    } \
+ \
+  /* control */ \
+  if (_message->control_messages == NULL) \
+    { \
+	  _msg->msg_ctrllen = 0; \
+	  _msg->msg_ctrl = NULL; \
+    } \
+  else \
+    { \
+      _msg->msg_ctrllen = 2048; \
+      _msg->msg_ctrl = g_alloca (_msg->msg_ctrllen); \
+    } \
+ \
+  /* flags */ \
+  /*_msg->msg_flags = _message->flags;*/        \
+} G_STMT_END
+
+#else
+
 #define input_message_to_msghdr(message, msg) \
 G_STMT_START { \
   const GInputMessage  *_message = (message); \
@@ -4568,11 +4748,18 @@
     } \
  \
   /* flags */ \
-  _msg->msg_flags = _message->flags; \
+  /*_msg->msg_flags = _message->flags;*/        \
 } G_STMT_END
 
+#endif
+
 static void
-input_message_from_msghdr (const struct msghdr  *msg,
+input_message_from_msghdr (
+#if defined(__sgi)
+                           const struct xpg5_msghdr  *msg,
+#else
+                           const struct msghdr  *msg,
+#endif
                            GInputMessage        *message,
                            GSocket              *socket)
 {
@@ -4587,14 +4774,23 @@
   {
     GPtrArray *my_messages = NULL;
     struct cmsghdr *cmsg;
-
-    if (msg->msg_controllen >= sizeof (struct cmsghdr))
+#if defined(__sgi)
+    if (msg->msg_ctrllen >= sizeof (struct cmsghdr))
+      {
+        g_assert (message->control_messages != NULL);
+        for (cmsg = CMSG_FIRSTHDR (msg);
+             cmsg != NULL;
+             cmsg = CMSG_NXTHDR ((struct xpg5_msghdr *) msg, cmsg))
+          {
+#else
+    if (msg->msg_ctrllen >= sizeof (struct cmsghdr))
       {
         g_assert (message->control_messages != NULL);
         for (cmsg = CMSG_FIRSTHDR (msg);
              cmsg != NULL;
              cmsg = CMSG_NXTHDR ((struct msghdr *) msg, cmsg))
           {
+#endif
             GSocketControlMessage *control_message;
 
             control_message = g_socket_control_message_deserialize (cmsg->cmsg_level,
@@ -4634,7 +4830,7 @@
   }
 
   /* capture the flags */
-  message->flags = msg->msg_flags;
+  /*message->flags = msg->msg_flags;*/
 }
 #endif
 
@@ -4825,7 +5021,11 @@
 #ifndef G_OS_WIN32
   {
     GOutputMessage output_message;
+#if defined(__sgi)
+    struct xpg5_msghdr msg;
+#else
     struct msghdr msg;
+#endif
     gssize result;
     GError *child_error = NULL;
 
@@ -4846,7 +5046,11 @@
 
     while (1)
       {
+#if defined(__sgi)
+	result = _xpg5_sendmsg (socket->priv->fd, &msg, flags | G_SOCKET_DEFAULT_SEND_FLAGS);
+#else
 	result = sendmsg (socket->priv->fd, &msg, flags | G_SOCKET_DEFAULT_SEND_FLAGS);
+#endif
 	if (result < 0)
 	  {
 	    int errsv = get_socket_errno ();
@@ -5078,7 +5282,11 @@
     for (i = 0; i < num_messages; ++i)
       {
         GOutputMessage *msg = &messages[i];
+#if defined(__sgi)
+        struct xpg5_msghdr *msg_hdr = &msgvec[i].msg_hdr;
+#else
         struct msghdr *msg_hdr = &msgvec[i].msg_hdr;
+#endif
         GError *child_error = NULL;
 
         msgvec[i].msg_len = 0;
@@ -5312,7 +5520,11 @@
 #ifndef G_OS_WIN32
   {
     GInputMessage input_message;
+#if defined(__sgi)
+    struct xpg5_msghdr msg;
+#else
     struct msghdr msg;
+#endif
     gssize result;
 
     input_message.address = address;
@@ -5336,7 +5548,11 @@
     /* do it */
     while (1)
       {
+#if defined(__sgi)
+	result = _xpg5_recvmsg (socket->priv->fd, &msg, msg.msg_flags);
+#else
 	result = recvmsg (socket->priv->fd, &msg, msg.msg_flags);
+#endif
 #ifdef MSG_CMSG_CLOEXEC	
 	if (result < 0 && get_socket_errno () == EINVAL)
 	  {
@@ -5597,7 +5813,11 @@
     for (i = 0; i < num_messages; ++i)
       {
         GInputMessage *msg = &messages[i];
+#if defined(__sgi)
+        struct xpg5_msghdr *msg_hdr = &msgvec[i].msg_hdr;
+#else
         struct msghdr *msg_hdr = &msgvec[i].msg_hdr;
+#endif
 
         input_message_to_msghdr (msg, msg_hdr);
         msgvec[i].msg_len = 0;
diff -u -r glib-2.62.6-orig/gio/gtrashportal.c glib-2.62.6/gio/gtrashportal.c
--- glib-2.62.6-orig/gio/gtrashportal.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/gtrashportal.c	2020-12-15 17:22:06.485299160 +0000
@@ -86,10 +86,17 @@
 
   path = g_file_get_path (file);
 
+#if defined(__sgi)
+  fd = g_open (path, O_RDWR | O_CLOEXEC);
+  if (fd == -1 && errno == EISDIR)
+    /* If it is a directory, fall back to O_PATH */
+    fd = g_open (path, O_PATH | O_CLOEXEC | O_RDONLY);
+#else
   fd = g_open (path, O_RDWR | O_CLOEXEC | O_NOFOLLOW);
   if (fd == -1 && errno == EISDIR)
     /* If it is a directory, fall back to O_PATH */
     fd = g_open (path, O_PATH | O_CLOEXEC | O_RDONLY | O_NOFOLLOW);
+#endif
 
   errsv = errno;
 
diff -u -r glib-2.62.6-orig/gio/gunixfdmessage.c glib-2.62.6/gio/gunixfdmessage.c
--- glib-2.62.6-orig/gio/gunixfdmessage.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/gunixfdmessage.c	2020-12-15 17:22:06.487075560 +0000
@@ -48,6 +48,10 @@
 #include <fcntl.h>
 #include <errno.h>
 
+#if defined(__sgi)
+# define SCM_RIGHTS 0x01
+#endif
+
 #include "gunixfdmessage.h"
 #include "gunixfdlist.h"
 #include "gnetworking.h"
diff -u -r glib-2.62.6-orig/gio/gunixmounts.c glib-2.62.6/gio/gunixmounts.c
--- glib-2.62.6-orig/gio/gunixmounts.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/gunixmounts.c	2020-12-15 17:22:06.492802200 +0000
@@ -71,6 +71,7 @@
 #include "gthemedicon.h"
 #include "gcontextspecificgroup.h"
 
+static const char * DEVROOTPATH = "/dev/otherroot";
 
 #ifdef HAVE_MNTENT_H
 static const char *_resolve_dev_root (void);
@@ -517,7 +518,7 @@
       gboolean is_read_only = FALSE;
 
       device_path = mnt_fs_get_source (fs);
-      if (g_strcmp0 (device_path, "/dev/root") == 0)
+      if (g_strcmp0 (device_path, DEVROOTPATH) == 0)
         device_path = _resolve_dev_root ();
 
       mount_options = mnt_fs_strdup_options (fs);
@@ -565,6 +566,51 @@
 G_LOCK_DEFINE_STATIC(getmntent);
 #endif
 
+/* Helper struct + function to create a g_slist containing the
+ * mntent entries so we don't have to G_LOCK
+ */
+typedef struct mntent_entry
+{
+  struct mntent mntent;
+} mntent_entry_s;
+
+static GSList * get_gslist_getmntent( FILE * file )
+{
+  GSList * ret_gslist=NULL;
+  GSList * el=NULL;
+  struct mntent *mntent;
+
+  G_LOCK (getmntent);
+  while ((mntent = getmntent (file)) != NULL)
+    {
+      mntent_entry_s * val = malloc(sizeof(mntent_entry_s));
+      val->mntent = *mntent;
+      el = g_slist_append( el, val );
+    }
+  G_UNLOCK (getmntent);
+  if( el != NULL ) {
+    ret_gslist = el;
+  }
+
+  return ret_gslist;
+}
+
+static void free_gslist_getmntent( GSList * gslist )
+{
+  if( gslist != NULL ) {
+    GSList * el = gslist;
+    do
+      {
+        void * data = el->data;
+        mntent_entry_s * val = (mntent_entry_s *)data;
+        free(val);
+      }
+    while( (el = g_slist_next(el)) != NULL );
+
+    g_slist_free( gslist );
+  }
+}
+
 static GList *
 _g_get_unix_mounts (void)
 {
@@ -578,7 +624,12 @@
   GUnixMountEntry *mount_entry;
   GHashTable *mounts_hash;
   GList *return_list;
+  GSList * mntent_list;
+  GSList * ent;
   
+  const char *device_path;
+  gboolean is_read_only;
+
   read_file = get_mtab_read_file ();
 
   file = setmntent (read_file, "r");
@@ -591,13 +642,20 @@
   
 #ifdef HAVE_GETMNTENT_R
   while ((mntent = getmntent_r (file, &ent, buf, sizeof (buf))) != NULL)
+    {
 #else
-  G_LOCK (getmntent);
-  while ((mntent = getmntent (file)) != NULL)
+    // G_LOCK (getmntent);
+    // while ((mntent = getmntent (file)) != NULL)
+    mntent_list = get_gslist_getmntent( file );
+  if( mntent_list != NULL ) {
+    ent = mntent_list;
+    do {
+      void * data = ent->data;
+      mntent_entry_s * val = (mntent_entry_s *)data;
+      mntent = &(val->mntent);
 #endif
-    {
-      const char *device_path = NULL;
-      gboolean is_read_only = FALSE;
+      device_path = NULL;
+      is_read_only = FALSE;
 
       /* ignore any mnt_fsname that is repeated and begins with a '/'
        *
@@ -614,7 +672,7 @@
 	  g_hash_table_lookup (mounts_hash, mntent->mnt_fsname))
         continue;
 
-      if (g_strcmp0 (mntent->mnt_fsname, "/dev/root") == 0)
+      if (g_strcmp0 (mntent->mnt_fsname, DEVROOTPATH) == 0)
         device_path = _resolve_dev_root ();
       else
         device_path = mntent->mnt_fsname;
@@ -636,7 +694,13 @@
 			   mount_entry->device_path);
 
       return_list = g_list_prepend (return_list, mount_entry);
+#if defined(HAVE_GETMNTENT_R)
     }
+#else
+  } while( (ent = g_slist_next(ent)) != NULL );
+    }
+  free_gslist_getmntent( mntent_list );
+#endif
   g_hash_table_destroy (mounts_hash);
   
   endmntent (file);
@@ -1054,7 +1118,7 @@
         }
 
       device_path = mnt_fs_get_source (fs);
-      if (g_strcmp0 (device_path, "/dev/root") == 0)
+      if (g_strcmp0 (device_path, DEVROOTPATH) == 0)
         device_path = _resolve_dev_root ();
 
       mount_point = create_unix_mount_point (device_path,
@@ -1123,7 +1187,7 @@
         continue;
 #endif
 
-      if (strcmp (mntent->mnt_fsname, "/dev/root") == 0)
+      if (strcmp (mntent->mnt_fsname, DEVROOTPATH) == 0)
         device_path = _resolve_dev_root ();
       else
         device_path = mntent->mnt_fsname;
@@ -3048,7 +3112,7 @@
   /* otherwise we're going to find it right away.. */
   have_real_dev_root = TRUE;
   
-  if (stat ("/dev/root", &statbuf) == 0) 
+  if (stat (DEVROOTPATH, &statbuf) == 0) 
     {
       if (! S_ISLNK (statbuf.st_mode)) 
         {
@@ -3095,7 +3159,7 @@
        else 
         {
           char *resolved;
-          resolved = _resolve_symlink ("/dev/root");
+          resolved = _resolve_symlink (DEVROOTPATH);
           if (resolved != NULL)
             {
               strncpy (real_dev_root, resolved, sizeof (real_dev_root) - 1);
@@ -3107,7 +3171,7 @@
     }
   
   /* bah sucks.. */
-  strcpy (real_dev_root, "/dev/root");
+  strcpy (real_dev_root, DEVROOTPATH);
   
 found:
   return real_dev_root;
diff -u -r glib-2.62.6-orig/gio/tests/desktop-app-info.c glib-2.62.6/gio/tests/desktop-app-info.c
--- glib-2.62.6-orig/gio/tests/desktop-app-info.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/tests/desktop-app-info.c	2020-12-15 17:22:06.495193640 +0000
@@ -80,9 +80,9 @@
 
   g_object_unref (info);
 
-  if (g_file_test ("/usr/share/applications/gedit.desktop", G_FILE_TEST_EXISTS))
+  if (g_file_test ("/usr/sgug/share/applications/gedit.desktop", G_FILE_TEST_EXISTS))
     {
-      info = (GAppInfo*)g_desktop_app_info_new_from_filename ("/usr/share/applications/gedit.desktop");
+      info = (GAppInfo*)g_desktop_app_info_new_from_filename ("/usr/sgug/share/applications/gedit.desktop");
       g_assert_nonnull (info);
      
       res = g_app_info_can_delete (info);
diff -u -r glib-2.62.6-orig/gio/tests/file.c glib-2.62.6/gio/tests/file.c
--- glib-2.62.6-orig/gio/tests/file.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/tests/file.c	2020-12-15 17:22:06.498233640 +0000
@@ -989,6 +989,7 @@
                                   &num_dirs,
                                   &num_files,
                                   &error);
+
   g_assert (ok);
   g_assert_no_error (error);
 
diff -u -r glib-2.62.6-orig/gio/tests/socket.c glib-2.62.6/gio/tests/socket.c
--- glib-2.62.6-orig/gio/tests/socket.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/tests/socket.c	2020-12-15 17:22:06.501721080 +0000
@@ -1336,10 +1336,13 @@
   gint fd;
   GError *error;
   GSocket *s;
-
+  //errno = 0;
   fd = socket (AF_UNIX, SOCK_STREAM, 0);
   g_assert_cmpint (fd, !=, -1);
 
+  //printf("Exiting. errno=%d\n", errno);
+  //exit(1);
+
   error = NULL;
   s = g_socket_new_from_fd (fd, &error);
   g_assert_no_error (error);
@@ -1903,11 +1906,14 @@
                        &error);
   if (sock != NULL)
     {
+      printf("Assuming ipv6 ok\n");
       ipv6_supported = TRUE;
       g_object_unref (sock);
     }
   else
     {
+      printf("Assuming ipv6 not ok\n");
+      errno = 0;
       g_assert_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED);
       g_clear_error (&error);
     }
diff -u -r glib-2.62.6-orig/gio/xdgmime/xdgmime.c glib-2.62.6/gio/xdgmime/xdgmime.c
--- glib-2.62.6-orig/gio/xdgmime/xdgmime.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gio/xdgmime/xdgmime.c	2020-12-15 17:22:06.503995880 +0000
@@ -235,7 +235,7 @@
   xdg_data_dirs = getenv ("XDG_DATA_DIRS");
 
   if (xdg_data_dirs == NULL)
-    xdg_data_dirs = "/usr/local/share/:/usr/share/";
+    xdg_data_dirs = "/usr/sgug/share/:/usr/share/";
 
   /* Work out how many dirs we’re dealing with. */
   if (xdg_data_home != NULL || home != NULL)
diff -u -r glib-2.62.6-orig/glib/gcharset.c glib-2.62.6/glib/gcharset.c
--- glib-2.62.6-orig/glib/gcharset.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gcharset.c	2020-12-15 17:22:06.506063240 +0000
@@ -407,7 +407,7 @@
   if (g_once_init_enter (&alias_table))
     {
       GHashTable *table = g_hash_table_new (g_str_hash, g_str_equal);
-      read_aliases ("/usr/share/locale/locale.alias", table);
+      read_aliases ("/usr/sgug/share/locale/locale.alias", table);
       g_once_init_leave (&alias_table, table);
     }
 
diff -u -r glib-2.62.6-orig/glib/giounix.c glib-2.62.6/glib/giounix.c
--- glib-2.62.6-orig/glib/giounix.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/giounix.c	2020-12-15 17:22:06.508005320 +0000
@@ -31,7 +31,17 @@
 
 #include "config.h"
 
+#if defined(__sgi)
+/* Needed to get the right declarations for select() before POSIX_SOURCE
+ * define
+ */
+#include <unistd.h>
+#include <sys/types.h>
+#include <bstring.h>
+#include <sys/time.h>
+#else
 #define _POSIX_SOURCE		/* for SSIZE_MAX */
+#endif
 
 #include <sys/types.h>
 #include <sys/stat.h>
diff -u -r glib-2.62.6-orig/glib/glibconfig.h.in glib-2.62.6/glib/glibconfig.h.in
--- glib-2.62.6-orig/glib/glibconfig.h.in	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/glibconfig.h.in	2020-12-15 17:22:06.509469560 +0000
@@ -16,7 +16,7 @@
  * system printf functions.  This is useful to know, for example,
  * when using glibc's register_printf_function().
  */
-#mesondefine GLIB_USING_SYSTEM_PRINTF
+/*#mesondefine GLIB_USING_SYSTEM_PRINTF*/
 
 #mesondefine GLIB_STATIC_COMPILATION
 #mesondefine GOBJECT_STATIC_COMPILATION
diff -u -r glib-2.62.6-orig/glib/gmain.c glib-2.62.6/glib/gmain.c
--- glib-2.62.6-orig/glib/gmain.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gmain.c	2020-12-15 17:22:06.516661560 +0000
@@ -2844,7 +2844,11 @@
   struct timespec ts;
   gint result;
 
+#if defined(__sgi)
+  result = clock_gettime (CLOCK_SGI_CYCLE, &ts);
+#else
   result = clock_gettime (CLOCK_MONOTONIC, &ts);
+#endif
 
   if G_UNLIKELY (result != 0)
     g_error ("GLib requires working CLOCK_MONOTONIC");
diff -u -r glib-2.62.6-orig/glib/gmessages.c glib-2.62.6/glib/gmessages.c
--- glib-2.62.6-orig/glib/gmessages.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gmessages.c	2020-12-15 17:22:06.521531320 +0000
@@ -1053,9 +1053,11 @@
     }
   else
     {
-      GError *err = NULL;
+      GError *err;
+      gchar *result;
+      err = NULL;
+      result = g_convert_with_fallback (string, -1, charset, "UTF-8", "?", NULL, NULL, &err);
       
-      gchar *result = g_convert_with_fallback (string, -1, charset, "UTF-8", "?", NULL, NULL, &err);
       if (result)
 	return result;
       else
diff -u -r glib-2.62.6-orig/glib/gnulib/fpucw.h glib-2.62.6/glib/gnulib/fpucw.h
--- glib-2.62.6-orig/glib/gnulib/fpucw.h	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gnulib/fpucw.h	2020-12-15 17:22:06.523251080 +0000
@@ -88,6 +88,36 @@
 # define END_LONG_DOUBLE_ROUNDING() \
   SET_FPUCW (oldcw)
 
+#elif defined(__sgi)
+
+typedef unsigned int fpucw_t;
+
+# include <sys/fpu.h>
+
+# define FPU_PC_MASK 0
+# define FPU_PC_DOUBLE 0
+# define FPU_PC_EXTENDED 0
+
+# define GET_FPUCW() 0
+# define SET_FPUCW(word) (void)(word)
+
+# define DECL_LONG_DOUBLE_ROUNDING              \
+  union fpc_csr old_csr, new_csr;
+
+# define BEGIN_LONG_DOUBLE_ROUNDING()                     \
+  do {                                                    \
+    old_csr.fc_word = get_fpc_csr();                      \
+    new_csr.fc_word = old_csr.fc_word;                    \
+    new_csr.fc_struct.flush=0;                            \
+    new_csr.fc_struct.rounding_mode=ROUND_TO_NEAREST;     \
+    set_fpc_csr(new_csr.fc_word);                         \
+  } while (0)
+
+# define END_LONG_DOUBLE_ROUNDING()             \
+  do {                                          \
+    set_fpc_csr(old_csr.fc_word);               \
+  } while (0)
+
 #else
 
 typedef unsigned int fpucw_t;
diff -u -r glib-2.62.6-orig/glib/gnulib/meson.build glib-2.62.6/glib/gnulib/meson.build
--- glib-2.62.6-orig/glib/gnulib/meson.build	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gnulib/meson.build	2020-12-15 17:22:06.524822760 +0000
@@ -323,14 +323,16 @@
                          output: 'gnulib_math.h',
                          configuration: math_h_config)
 
-gnulib_sources = ['asnprintf.c', 'printf.c', 'printf-args.c', 'printf-parse.c', 'printf-frexp.c', 'printf-frexpl.c', 'isnand.c', 'isnanl.c', 'vasnprintf.c']
+# We already have all these in libdicl
+gnulib_sources = ['asnprintf.c', 'printf.c', 'printf-args.c', 'printf-parse.c', 'printf-frexp.c', 'printf-frexpl.c', 'isnand.c', 'isnanf.c', 'isnanl.c', 'vasnprintf.c']
+#gnulib_sources = ['printf.c','vasnprintf.c']
 
-if not gl_cv_func_frexp_works
-  gnulib_sources += ['frexp.c']
-endif
-if not gl_cv_func_frexpl_works
-  gnulib_sources += ['frexpl.c']
-endif
+#if not gl_cv_func_frexp_works
+#  gnulib_sources += ['frexp.c']
+#endif
+#if not gl_cv_func_frexpl_works
+#  gnulib_sources += ['frexpl.c']
+#endif
 
 gnulib_sources += other_needed_math_sources
 
diff -u -r glib-2.62.6-orig/glib/gnulib/vasnprintf.c glib-2.62.6/glib/gnulib/vasnprintf.c
--- glib-2.62.6-orig/glib/gnulib/vasnprintf.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gnulib/vasnprintf.c	2020-12-15 17:22:06.533635320 +0000
@@ -3072,7 +3072,7 @@
                         int sign = 0;
                         DECL_LONG_DOUBLE_ROUNDING
 
-                        BEGIN_LONG_DOUBLE_ROUNDING ();
+                        BEGIN_LONG_DOUBLE_ROUNDING();
 
                         if (signbit (arg)) /* arg < 0.0L or negative zero */
                           {
diff -u -r glib-2.62.6-orig/glib/goption.c glib-2.62.6/glib/goption.c
--- glib-2.62.6-orig/glib/goption.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/goption.c	2020-12-15 17:22:28.804163640 +0000
@@ -865,7 +865,11 @@
   if (context->help_enabled ||
       (context->main_group && context->main_group->n_entries > 0) ||
       context->groups != NULL)
+#if defined(__sgi)
+    g_string_append_printf (string, " %s", _("[OPTION.]"));
+#else
     g_string_append_printf (string, " %s", _("[OPTION…]"));
+#endif
 
   if (rest_description)
     {
diff -u -r glib-2.62.6-orig/glib/gspawn.c glib-2.62.6/glib/gspawn.c
--- glib-2.62.6-orig/glib/gspawn.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gspawn.c	2020-12-15 17:22:06.537967720 +0000
@@ -1626,7 +1626,6 @@
   if (!intermediate_child && working_directory == NULL && !close_descriptors &&
       !search_path_from_envp && child_setup == NULL)
     {
-      g_debug ("Launching with posix_spawn");
       status = do_posix_spawn (argv,
                                envp,
                                search_path,
@@ -1662,7 +1661,7 @@
     }
   else
     {
-      g_debug ("posix_spawn avoided %s%s%s%s%s",
+      g_debug ("posix_spawn avoided %s%s%s%s%s\n",
                !intermediate_child ? "" : "(automatic reaping requested) ",
                working_directory == NULL ? "" : "(workdir specified) ",
                !close_descriptors ? "" : "(fd close requested) ",
diff -u -r glib-2.62.6-orig/glib/gthread-posix.c glib-2.62.6/glib/gthread-posix.c
--- glib-2.62.6-orig/glib/gthread-posix.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gthread-posix.c	2020-12-15 17:22:06.540826360 +0000
@@ -661,7 +661,7 @@
 
   pthread_condattr_init (&attr);
 
-#ifdef HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP
+#if defined(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP) || defined(__sgi)
 #elif defined (HAVE_PTHREAD_CONDATTR_SETCLOCK) && defined (CLOCK_MONOTONIC)
   if G_UNLIKELY ((status = pthread_condattr_setclock (&attr, CLOCK_MONOTONIC)) != 0)
     g_thread_abort (status, "pthread_condattr_setclock");
@@ -901,6 +901,22 @@
     if ((status = pthread_cond_timedwait_relative_np (g_cond_get_impl (cond), g_mutex_get_impl (mutex), &ts)) == 0)
       return TRUE;
   }
+#elif defined(__sgi)
+  {
+    gint64 now = g_get_monotonic_time();
+    gint64 absendtime;
+
+    if (end_time <= now)
+      return FALSE;
+
+    absendtime = g_get_real_time () + (end_time - now);
+
+    ts.tv_sec = absendtime / 1000000;
+    ts.tv_nsec = (absendtime % 1000000) * 1000;
+
+    if ((status = pthread_cond_timedwait (g_cond_get_impl (cond), g_mutex_get_impl (mutex), &ts)) == 0)
+      return TRUE;
+  }
 #elif defined (HAVE_PTHREAD_CONDATTR_SETCLOCK) && defined (CLOCK_MONOTONIC)
   /* This is the exact check we used during init to set the clock to
    * monotonic, so if we're in this branch, timedwait() will already be
diff -u -r glib-2.62.6-orig/glib/gtimezone.c glib-2.62.6/glib/gtimezone.c
--- glib-2.62.6-orig/glib/gtimezone.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gtimezone.c	2020-12-15 17:22:06.544204520 +0000
@@ -416,7 +416,8 @@
 
   tzdir = getenv ("TZDIR");
   if (tzdir == NULL)
-    tzdir = "/usr/share/zoneinfo";
+    /* Yes, this doesn't exist on IRIX */
+    tzdir = "/usr/sgug/share/zoneinfo";
 
   /* identifier can be a relative or absolute path name;
      if relative, it is interpreted starting from /usr/share/zoneinfo
diff -u -r glib-2.62.6-orig/glib/gutils.c glib-2.62.6/glib/gutils.c
--- glib-2.62.6-orig/glib/gutils.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/gutils.c	2020-12-15 17:22:06.548662520 +0000
@@ -992,11 +992,17 @@
       const gsize size_large = (gsize) 256 * 256;
       gchar *tmp;
 
+#if defined(__sgi)
+      max = 0;
+#else
       max = sysconf (_SC_HOST_NAME_MAX);
+#endif
       if (max > 0 && max <= G_MAXSIZE - 1)
         size = (gsize) max + 1;
       else
-#ifdef HOST_NAME_MAX
+#if defined(__sgi)
+        size = MAXHOSTNAMELEN + 1;
+#elif defined(HOST_NAME_MAX)
         size = HOST_NAME_MAX + 1;
 #else
         size = _POSIX_HOST_NAME_MAX + 1;
@@ -2067,7 +2073,7 @@
    */
 #ifndef G_OS_WIN32
   if (!data_dirs || !data_dirs[0])
-    data_dirs = "/usr/local/share/:/usr/share/";
+    data_dirs = "/usr/sgug/share/:/usr/share/";
 
   data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
 #else
@@ -2323,59 +2329,59 @@
   const struct Format formats[4][6] = {
     {
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { KILOBYTE_FACTOR, N_("%.1f kB") },
+      { KILOBYTE_FACTOR, N_("%.1f kB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { MEGABYTE_FACTOR, N_("%.1f MB") },
+      { MEGABYTE_FACTOR, N_("%.1f MB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { GIGABYTE_FACTOR, N_("%.1f GB") },
+      { GIGABYTE_FACTOR, N_("%.1f GB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { TERABYTE_FACTOR, N_("%.1f TB") },
+      { TERABYTE_FACTOR, N_("%.1f TB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { PETABYTE_FACTOR, N_("%.1f PB") },
+      { PETABYTE_FACTOR, N_("%.1f PB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { EXABYTE_FACTOR,  N_("%.1f EB") }
+      { EXABYTE_FACTOR,  N_("%.1f EB") }
     },
     {
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { KIBIBYTE_FACTOR, N_("%.1f KiB") },
+      { KIBIBYTE_FACTOR, N_("%.1f KiB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { MEBIBYTE_FACTOR, N_("%.1f MiB") },
+      { MEBIBYTE_FACTOR, N_("%.1f MiB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { GIBIBYTE_FACTOR, N_("%.1f GiB") },
+      { GIBIBYTE_FACTOR, N_("%.1f GiB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { TEBIBYTE_FACTOR, N_("%.1f TiB") },
+      { TEBIBYTE_FACTOR, N_("%.1f TiB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { PEBIBYTE_FACTOR, N_("%.1f PiB") },
+      { PEBIBYTE_FACTOR, N_("%.1f PiB") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { EXBIBYTE_FACTOR, N_("%.1f EiB") }
+      { EXBIBYTE_FACTOR, N_("%.1f EiB") }
     },
     {
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { KILOBYTE_FACTOR, N_("%.1f kb") },
+      { KILOBYTE_FACTOR, N_("%.1f kb") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { MEGABYTE_FACTOR, N_("%.1f Mb") },
+      { MEGABYTE_FACTOR, N_("%.1f Mb") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { GIGABYTE_FACTOR, N_("%.1f Gb") },
+      { GIGABYTE_FACTOR, N_("%.1f Gb") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { TERABYTE_FACTOR, N_("%.1f Tb") },
+      { TERABYTE_FACTOR, N_("%.1f Tb") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { PETABYTE_FACTOR, N_("%.1f Pb") },
+      { PETABYTE_FACTOR, N_("%.1f Pb") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { EXABYTE_FACTOR,  N_("%.1f Eb") }
+      { EXABYTE_FACTOR,  N_("%.1f Eb") }
     },
     {
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { KIBIBYTE_FACTOR, N_("%.1f Kib") },
+      { KIBIBYTE_FACTOR, N_("%.1f Kib") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { MEBIBYTE_FACTOR, N_("%.1f Mib") },
+      { MEBIBYTE_FACTOR, N_("%.1f Mib") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { GIBIBYTE_FACTOR, N_("%.1f Gib") },
+      { GIBIBYTE_FACTOR, N_("%.1f Gib") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { TEBIBYTE_FACTOR, N_("%.1f Tib") },
+      { TEBIBYTE_FACTOR, N_("%.1f Tib") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { PEBIBYTE_FACTOR, N_("%.1f Pib") },
+      { PEBIBYTE_FACTOR, N_("%.1f Pib") },
       /* Translators: Keep the no-break space between %.1f and the unit symbol */
-      { EXBIBYTE_FACTOR, N_("%.1f Eib") }
+      { EXBIBYTE_FACTOR, N_("%.1f Eib") }
     }
   };
 
diff -u -r glib-2.62.6-orig/glib/tests/collate.c glib-2.62.6/glib/tests/collate.c
--- glib-2.62.6-orig/glib/tests/collate.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/tests/collate.c	2020-12-15 17:22:06.550652920 +0000
@@ -105,6 +105,172 @@
   do_collate (TRUE, TRUE, test);
 }
 
+/* No UTF8 locales on IRIX, so qsort won't have expected behaviour
+ * so lets redefine the test sets + results
+ */
+#if defined(__sgi)
+
+const gchar *input0[] = {
+  "z",
+  "c",
+  "eer34",
+  "223",
+  "er1",
+  "foo",
+  "bar",
+  "baz",
+  "GTK+",
+  NULL
+};
+
+const gchar *sorted0[] = {
+  "223",
+  "bar",
+  "baz",
+  "c",
+  "eer34",
+  "er1",
+  "foo",
+  "GTK+",
+  "z",
+  NULL
+};
+
+const gchar *file_sorted0[] = {
+  "223",
+  "bar",
+  "baz",
+  "c",
+  "eer34",
+  "er1",
+  "foo",
+  "GTK+",
+  "z",
+  NULL
+};
+
+const gchar *input1[] = {
+  "file.txt",
+  "file2.bla",
+  "file.c",
+  "file3.xx",
+  "bla001",
+  "bla02",
+  "bla03",
+  "bla4",
+  "bla10",
+  "bla100",
+  "event.c",
+  "eventgenerator.c",
+  "event.h",
+  NULL
+};
+
+const gchar *sorted1[] = {
+  "bla001",
+  "bla02",
+  "bla03",
+  "bla10",
+  "bla100",
+  "bla4",
+  "eventgenerator.c",
+  "event.c",
+  "event.h",
+  "file2.bla",
+  "file3.xx",
+  "file.c",
+  "file.txt",
+  NULL
+};
+
+const gchar *file_sorted1[] = {
+  "bla001",
+  "bla02",
+  "bla03",
+  "bla4",
+  "bla10",
+  "bla100",
+  "event.c",
+  "event.h",
+  "eventgenerator.c",
+  "file.c",
+  "file.txt",
+  "file2.bla",
+  "file3.xx",
+  NULL
+};
+
+const gchar *input2[] = {
+  "file26",
+  "file100",
+  "file1",
+  "file:foo",
+  "a.a",
+  "file027",
+  "file10",
+  "aa.a",
+  "file5",
+  "file0027",
+  "a-.a",
+  "file0000",
+  "file000x",
+  NULL
+};
+
+const gchar *sorted2[] = {
+  "aa.a",
+  "a-.a",
+  "a.a",
+  "file0000",
+  "file000x",
+  "file0027",
+  "file027",
+  "file1",
+  "file10",
+  "file100",
+  "file26",
+  "file5",
+  "file:foo",
+  NULL
+};
+
+const gchar *file_sorted2[] = {
+  /* Filename collation in OS X follows Finder style which gives
+   * a slightly different order from usual Linux locales. */
+#ifdef HAVE_CARBON
+  "a-.a",
+  "a.a",
+  "aa.a",
+  "file:foo",
+  "file0000",
+  "file000x",
+  "file1",
+  "file5",
+  "file10",
+  "file26",
+  "file0027",
+  "file027",
+  "file100",
+#else
+  "a.a",
+  "aa.a",
+  "a-.a",
+  "file0000",
+  "file000x",
+  "file1",
+  "file5",
+  "file10",
+  "file26",
+  "file027",
+  "file0027",
+  "file100",
+  "file:foo",
+#endif
+  NULL
+};
+
+#else
+
 const gchar *input0[] = {
   "z",
   "c",
@@ -267,6 +433,8 @@
   NULL
 };
 
+#endif
+
 int
 main (int argc, char *argv[])
 {
diff -u -r glib-2.62.6-orig/glib/tests/date.c glib-2.62.6/glib/tests/date.c
--- glib-2.62.6-orig/glib/tests/date.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/tests/date.c	2020-12-15 17:22:06.552928920 +0000
@@ -215,6 +215,11 @@
 
   g_test_bug ("793550");
 
+#if defined(__sgi)
+  g_test_skip ("pl_PL locale not available");
+  return;
+#endif
+
   if (setlocale (LC_ALL, "pl_PL") == NULL)
     {
       g_test_skip ("pl_PL locale not available");
diff -u -r glib-2.62.6-orig/glib/tests/gdatetime.c glib-2.62.6/glib/tests/gdatetime.c
--- glib-2.62.6-orig/glib/tests/gdatetime.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/tests/gdatetime.c	2020-12-15 17:22:06.557253800 +0000
@@ -1564,7 +1564,7 @@
   TEST_PRINTF ("%%", "%");
   TEST_PRINTF ("%", "");
   TEST_PRINTF ("%9", NULL);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(__sgi)
   TEST_PRINTF ("%Z", dst);
 #elif defined G_OS_WIN32
   g_assert (GetDynamicTimeZoneInformation (&dtz_info) != TIME_ZONE_ID_INVALID);
diff -u -r glib-2.62.6-orig/glib/tests/gvariant.c glib-2.62.6/glib/tests/gvariant.c
--- glib-2.62.6-orig/glib/tests/gvariant.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/tests/gvariant.c	2020-12-15 17:22:06.565275880 +0000
@@ -15,6 +15,7 @@
 
 #include <glib/gvariant-internal.h>
 #include <string.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <glib.h>
 
@@ -3831,7 +3832,8 @@
   gchar *pt, *p;
   gchar *res;
 
-  tree = tree_instance_new (NULL, 3);
+  //  tree = tree_instance_new (NULL, 3);
+  tree = tree_instance_new (NULL, 2);
   value = tree_instance_get_gvariant (tree);
   tree_instance_free (tree);
 
@@ -3840,6 +3842,8 @@
 
   parsed = g_variant_parse (NULL, pt, NULL, NULL, NULL);
   res = g_variant_print (parsed, FALSE);
+  //  printf("p=\n%s\n", p);
+  //  printf("res=\n%s\n", res);
   g_assert_cmpstr (p, ==, res);
   g_variant_unref (parsed);
   g_free (res);
diff -u -r glib-2.62.6-orig/glib/tests/protocol.c glib-2.62.6/glib/tests/protocol.c
--- glib-2.62.6-orig/glib/tests/protocol.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/tests/protocol.c	2020-12-15 17:22:06.567002920 +0000
@@ -20,6 +20,8 @@
  * if advised of the possibility of such damage.
  */
 
+#include <stdio.h>
+
 #include <errno.h>  /* errno */
 #include <glib.h>
 #ifdef G_OS_UNIX
diff -u -r glib-2.62.6-orig/glib/tests/strfuncs.c glib-2.62.6/glib/tests/strfuncs.c
--- glib-2.62.6-orig/glib/tests/strfuncs.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/glib/tests/strfuncs.c	2020-12-15 17:22:06.571116360 +0000
@@ -1105,7 +1105,11 @@
 {
   gchar *str_end = NULL;
   double value = 0.0;
+#if defined(__sgi)
   const double gold_ratio = 1.61803398874989484;
+#else
+  const double gold_ratio = 1.61803398874989484;
+#endif
   const gchar *gold_ratio_str = "1.61803398874989484";
   const gchar *minus_gold_ratio_str = "-1.61803398874989484";
 
@@ -1557,7 +1561,7 @@
 #endif
   check_strtod_string ("-.75,0", -0.75, TRUE, 4);
 
-#ifndef _MSC_VER
+#if !defined(_MSC_VER) && !defined(__sgi)
   /* the values of d in the following 2 tests generate a C1064 compiler limit error */
   d = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0;
   g_assert_true (d == g_ascii_strtod (g_ascii_dtostr (buffer, sizeof (buffer), d), NULL));
diff -u -r glib-2.62.6-orig/gobject/tests/genmarshal.py glib-2.62.6/gobject/tests/genmarshal.py
--- glib-2.62.6-orig/gobject/tests/genmarshal.py	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gobject/tests/genmarshal.py	2020-12-15 17:22:06.573360520 +0000
@@ -1,4 +1,4 @@
-#!/usr/bin/python3
+#!/usr/sgug/bin/python3
 # -*- coding: utf-8 -*-
 #
 # Copyright © 2019 Endless Mobile, Inc.
diff -u -r glib-2.62.6-orig/gobject/tests/mkenums.py glib-2.62.6/gobject/tests/mkenums.py
--- glib-2.62.6-orig/gobject/tests/mkenums.py	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/gobject/tests/mkenums.py	2020-12-15 17:22:06.574941320 +0000
@@ -1,4 +1,4 @@
-#!/usr/bin/python3
+#!/usr/sgug/bin/python3
 # -*- coding: utf-8 -*-
 #
 # Copyright © 2018 Endless Mobile, Inc.
diff -u -r glib-2.62.6-orig/meson.build glib-2.62.6/meson.build
--- glib-2.62.6-orig/meson.build	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/meson.build	2020-12-15 17:22:06.578558200 +0000
@@ -5,7 +5,7 @@
   default_options : [
     'buildtype=debugoptimized',
     'warning_level=1',
-    'c_std=gnu89'
+    'c_std=gnu99'
   ]
 )
 
@@ -449,7 +449,6 @@
   'link',
   'localtime_r',
   'lstat',
-  'mbrtowc',
   'memalign',
   'mmap',
   'newlocale',
@@ -475,12 +474,13 @@
   'valloc',
   'vasprintf',
   'vsnprintf',
-  'wcrtomb',
   'wcslen',
   'wcsnlen',
   'sysctlbyname',
   '_NSGetEnviron',
 ]
+# Not for IRIX  'mbrtowc',
+# Not for IRIX  'wcrtomb',
 
 if glib_conf.has('HAVE_SYS_STATVFS_H')
   functions += ['statvfs']
diff -u -r glib-2.62.6-orig/tests/mapping-test.c glib-2.62.6/tests/mapping-test.c
--- glib-2.62.6-orig/tests/mapping-test.c	2020-03-18 13:16:11.000000000 +0000
+++ glib-2.62.6/tests/mapping-test.c	2020-12-15 17:22:06.579865240 +0000
@@ -208,7 +208,11 @@
   signal (SIGUSR1, handle_usr1);
 #endif
 
+#if defined(__sgi)
+  g_snprintf (pid, sizeof(pid), "%ld", getpid ());
+#else
   g_snprintf (pid, sizeof(pid), "%d", getpid ());
+#endif
   child_argv[0] = argv0;
   child_argv[1] = "mapchild";
   child_argv[2] = pid;
